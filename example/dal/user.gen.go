/*
NOTE! This code is autogenerated.
Don't manually change this code.
Version [545815e97fb37cab651ffa9b0aa5b53269900274d17c376fb000355cdc7e3358]
*/
package dal

import (
    "context"
    "encoding/gob"
    "database/sql"
    "errors"
    "strings"

    "fmt"
    "time"

    "github.com/patrickmn/go-cache"
    "github.com/sony/gobreaker"
)

func init() {
	gob.Register(User{})
}


type User struct {
    ID        int64
    version   int32
    
    Age int8 `json:"age"`
    Birthdate sql.NullTime `json:"birthdate"`
    Email string `json:"email"`
    Status sql.NullString `json:"status"`
    Uuid string `json:"uuid"`

    Created   time.Time
    Updated   time.Time
}

type UserDAL struct {
    dbProvider          DBProvider
    cache               *cache.Cache  // Simple TTL cache for single items, for inmemory cache management
  	listCache           *cache.Cache // Cache for lists. Simple TTL cache, for inmemory cache management
    countCache          *cache.Cache // Cache for counts. Simple TTL cache, for inmemory cache management
    cacheProvider       CacheProvider
    configProvider      ConfigProvider
	dbBreaker           *gobreaker.CircuitBreaker
}

func NewUserDAL(provider DBProvider, cacheProvider CacheProvider,
    configProvider ConfigProvider, dbSettings gobreaker.Settings) *UserDAL {

    if configProvider == nil {
        configProvider = DefaultConfigProvider{}
    }

    if cacheProvider == nil {
        cacheProvider = NoopCacheProvider{}
    }

    if dbSettings.Name == "" {
        dbSettings.Name = "user_dal"
    }
    if dbSettings.ReadyToTrip == nil {
        dbSettings.ReadyToTrip = func(counts gobreaker.Counts) bool {
            return counts.ConsecutiveFailures > 4
        }
    }
    if dbSettings.OnStateChange == nil {
		dbSettings.OnStateChange = OnCircuitBreakerStateChange
	}

    if dbSettings.Timeout == 0 {
        dbSettings.Timeout = time.Second * 20
    }

    // Default expiration is 5 minutes and cleanup of 10 minutes
   	singleCache := cache.New(5*time.Minute, 10*time.Minute)
	listCache := cache.New(5*time.Minute, 10*time.Minute)
    countCache := cache.New(5*time.Minute, 10*time.Minute)

    newDAL := &UserDAL{
        dbProvider:     provider,
        cache:          singleCache,
        listCache:      listCache,
        countCache:     countCache,
        cacheProvider:  cacheProvider,
        configProvider: configProvider,
		dbBreaker:      gobreaker.NewCircuitBreaker(dbSettings),
    }

    // initialize cache invalidation handler
    cacheProvider.OnCacheInvalidated("user", newDAL.onCacheInvalidated)
    cacheProvider.OnCacheFlushList("user", newDAL.onCacheFlushList)

    return newDAL
}

func (d *UserDAL) getCacheKey(id int64) string {
    return fmt.Sprintf("user_id:%d", id)
}



func (d *UserDAL) InvalidateCache(entity *User) {
    cacheKey := d.getCacheKey(entity.ID)
	d.cache.Delete(cacheKey)

	// Invalidate cache entry across instances
	d.cacheProvider.InvalidateCache("user", cacheKey)
}

func (d *UserDAL) FlushListCache() {
    d.listCache.Flush()
    d.countCache.Flush()

    // Invalidate cache entry across instances
    d.cacheProvider.FlushListCache("user")
}


// Handles cache invalidations. Just remove cached entry by key
func (d *UserDAL) onCacheInvalidated(key string) {
    d.cache.Delete(key)
}

// Handles cache_flush_list. Just clears all lists cache.
func (d *UserDAL) onCacheFlushList() {
    d.listCache.Flush()
    d.countCache.Flush()
}




func (d *UserDAL) Create(ctx context.Context, entity *User) (*User, error) {
    if d.configProvider.BlockedWrites("user") {
        return nil, ErrOperationBlocked
    }

	if entity.ID > 0 {
		return nil, fmt.Errorf("UserDAL.Create failed as ID > 0")
	}

	const operation = "create"
	dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

	_, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.create(ctx, entity)
	})

	if err != nil {
		return nil, err
	}

	d.setCached(entity)

	// All lists cache should be flushed.
	d.FlushListCache()

	return entity, err
}

func (d *UserDAL) create(ctx context.Context, entity *User) (*User, error) {
	const operation = "create"
	start := time.Now()

	entity.Created = time.Now()
	entity.Updated = time.Now()

	query := `
		INSERT INTO users (age,birthdate,email,status,uuid,
created,updated)
		VALUES (?,?,?,?,?,?,?)
	`

    db, dbErr := d.dbProvider.GetDatabase("user", true);
    if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
        return nil, dbErr
    }

	result, err := db.ExecContext(ctx, query,entity.Age, entity.Birthdate, entity.Email, entity.Status, entity.Uuid,
		entity.Created, entity.Updated)

	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return nil, fmt.Errorf("failed to insert User: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return nil, fmt.Errorf("failed to get last insert ID: %w", err)
	}

	entity.ID = id
	dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(start).Seconds())
	return entity, nil
}



func (d *UserDAL) CreateBulk(ctx context.Context, entities []*User) ([]*User, error) {
	if d.configProvider.BlockedWrites("user") {
		return nil, ErrOperationBlocked
	}

	const operation = "create_bulk"
	dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

	result, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.createBulk(ctx, entities)
	})

	if err != nil {
		return nil, err
	}

	// All lists cache should be flushed.
	d.FlushListCache()

	return result.([]*User), err
}

func (d *UserDAL) createBulk(ctx context.Context, entities []*User) ([]*User, error) {
	const operation = "create_bulk"
	start := time.Now()

	if len(entities) == 0 {
		return nil, fmt.Errorf("empty entities list")
	}

	// Prepare data and parameters
	valuePlaceholders := make([]string, 0, len(entities))
	params := make([]interface{}, 0, len(entities)*7) // 7 fields per entity
	now := time.Now()

	for _, entity := range entities {
		if entity.ID > 0 {
			return nil, fmt.Errorf("entity with existing ID in bulk create")
		}

		entity.Created = now
		entity.Updated = now

		valuePlaceholders = append(valuePlaceholders, "(?,?,?,?,?,?,?)")
		params = append(params,entity.Age,entity.Birthdate,entity.Email,entity.Status,entity.Uuid,
            entity.Created,
            entity.Updated,
		)
	}

	query := fmt.Sprintf(`
			INSERT INTO users
			(age,birthdate,email,status,uuid,
created,updated)
			VALUES %s
		`, strings.Join(valuePlaceholders, ","))

	db, dbErr := d.dbProvider.GetDatabase("user", true)
	if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return nil, dbErr
	}

	result, err := db.ExecContext(ctx, query, params...)
	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return nil, fmt.Errorf("failed to bulk insert users: %w", err)
	}

	// Get generated IDs (works for MySQL/SQLite)
	lastID, err := result.LastInsertId()
	if err != nil {
		return nil, fmt.Errorf("failed to get last insert ID: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return nil, fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected != int64(len(entities)) {
		return nil, fmt.Errorf("mismatch between inserted rows and entity count")
	}

	// Assign generated IDs sequentially
	for i := range entities {
		entities[i].ID = lastID + int64(i)
	}

	dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(start).Seconds())
	return entities, nil
}



// ErrNotFound is returned in case there was nothing to update; either missing id or newer version of entity is already stored.
func (d *UserDAL) Update(ctx context.Context, entity *User) error {
    if d.configProvider.BlockedWrites("user") {
        return ErrOperationBlocked
    }

	const operation = "update"
	dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()
	// 1. Get existing entity to check for changes. Required for proper cache invalidation.
	existing, err := d.GetByID(ctx, entity.ID)
	if err != nil {
		return fmt.Errorf("failed to get existing User, id: %v, err: %w", entity.ID, err)
	}

	
	var oldEmail string
	if existing.Email != entity.Email {
		oldEmail = existing.Email
	}
		
	var oldUuid string
	if existing.Uuid != entity.Uuid {
		oldUuid = existing.Uuid
	}
		

	// Perform the update in DB.
	_, err2 := d.dbBreaker.Execute(func() (interface{}, error) {
		return nil, d.update(ctx, entity)
	})

	if err2 != nil {
		return err2
	}

	
	if oldEmail != "" {
		oldCacheKey := fmt.Sprintf("user_email:%s", oldEmail)
		d.cache.Delete(oldCacheKey)
		d.cacheProvider.InvalidateCache("user", oldCacheKey)
	}
	if oldUuid != "" {
		oldCacheKey := fmt.Sprintf("user_uuid:%s", oldUuid)
		d.cache.Delete(oldCacheKey)
		d.cacheProvider.InvalidateCache("user", oldCacheKey)
	}

	// Lets clear item from cache on other instances and here
	d.InvalidateCache(entity)
	d.FlushListCache()

	entity.version++
	// our entity can become part of local cache
	d.setCached(entity)

	return nil
}

func (d *UserDAL) update(ctx context.Context, entity *User) error {
	const operation = "update"
	start := time.Now()

	entity.Updated = time.Now()

	query := `
		UPDATE users
		SET age = ?,birthdate = ?,email = ?,status = ?,uuid = ?, updated=?, version = version + 1
		WHERE id = ? AND version = ?
	`

    db, dbErr := d.dbProvider.GetDatabase("user", true);
    if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
        return dbErr
    }

	res, err := db.ExecContext(ctx, query,entity.Age, entity.Birthdate, entity.Email, entity.Status, entity.Uuid,
	entity.Updated, entity.ID, entity.version)

	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return fmt.Errorf("failed to update User: %w", err)
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		// clean out cache for specific ID to limit stale cache entries
		d.InvalidateCache(entity)
		return ErrNotFound
	}

	dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(start).Seconds())

	return nil
}



func (d *UserDAL) Store(ctx context.Context, entity *User) (*User, error) {
    if d.configProvider.BlockedWrites("user") {
        return nil, ErrOperationBlocked
    }

	const operation = "store"
	dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

	var result *User
	var err error

	if entity.ID > 0 {
		// Update existing entity
		err = d.Update(ctx, entity)
		result = entity // Return the same entity after update
	} else {
		// Create new entity
		result, err = d.Create(ctx, entity)
	}

	// Handle errors
	if err != nil {
		return nil, err
	}

	return result, nil
}




// Deletes entity by id,
// returns ErrNotFound in case nothing is deleted.
func (d *UserDAL) Delete(ctx context.Context, entity *User) error {
    if d.configProvider.BlockedWrites("user") {
        return ErrOperationBlocked
    }

	if entity.ID == 0 {
		// nothing can be deleted as entity is not created.
		return ErrNotFound
	}

	const operation = "delete"
	dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

	_, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return nil, d.delete(ctx, entity.ID)
	})

	if err != nil {
		return err
	}

	// Lets clear item from cache and on next use use DB as source of truth
	d.InvalidateCache(entity)
	d.FlushListCache()

	return err
}

func (d *UserDAL) delete(ctx context.Context, id int64) error {
	start := time.Now()
	const operation = "delete"

	query := `
		DELETE FROM users
		WHERE id = ?
	`

    db, dbErr := d.dbProvider.GetDatabase("user", true);
    if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
        return dbErr
    }

	res, err := db.ExecContext(ctx, query, id)
	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return fmt.Errorf("failed to delete user: %w", err)
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return ErrNotFound
	}

	dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(start).Seconds())
	return nil
}




func (d *UserDAL) GetByID(ctx context.Context, id int64) (*User, error) {
    if d.configProvider.BlockedReads("user") {
        return nil, ErrOperationBlocked
    }

    const operation = "get_by_id"
    dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

	// Load from cache
    cachedEntity, _ := d.getByIDCached(id)
    if cachedEntity != nil {
        return cachedEntity, nil
    }

	// Fallback to database if cache miss or decoding fails
	result, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.getByID(ctx, id)
	})

	if err != nil {
		return nil, err
	}

	entity, ok := result.(*User)
    if !ok {
        return nil, fmt.Errorf("invalid type")
    }

    _ = d.setCached(entity)

    return entity, err
}

func (d *UserDAL) setCached(entity *User) error {
    // if we have not reached the maximum number of items set the cache. otherwise expirations will
	// handle this
    itemCount := d.cache.ItemCount()
    if itemCount < 100000 {
        cacheKey := d.getCacheKey(entity.ID)

        // Store in cache with new format
        dalCacheWritesCounter.WithLabelValues("user").Inc()
        dalCacheSizeGauge.WithLabelValues("user").Set(float64(itemCount+1))

        copy := *entity
		d.cache.Set(cacheKey, &copy, time.Second*300)
    }

    return nil
}

// Gets entity from cache only or return nil
func (d *UserDAL) getByIDCached(id int64) (*User, error) {
    const operation = "get_by_id"
    cacheKey := d.getCacheKey(id)
    val, found := d.cache.Get(cacheKey)
    if found {
        entity, ok := val.(*User)
        if !ok {
            return nil, fmt.Errorf("UserDAL.GetById: Cache returned wrong type")
        }

        dalCacheHitsCounter.WithLabelValues("user", operation).Inc()
        copy := *entity
        return &copy, nil
    }

    // Cache missed or error during fetching cached data
	dalCacheMissesCounter.WithLabelValues("user", operation).Inc()

    return nil, nil
}

func (d *UserDAL) getByID(ctx context.Context, id int64) (*User, error) {
    const operation = "get_by_id"
    dbStart := time.Now();

    query := `
        SELECT id, version, age, birthdate, email, status, uuid, created, updated
        FROM users
        WHERE id = ?
    `

    db, dbErr := d.dbProvider.GetDatabase("user", false);
    if dbErr != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
        return nil, dbErr
    }

    row := db.QueryRowContext(ctx, query, id)
    var entity User
    err := row.Scan(
        &entity.ID,
        &entity.version,&entity.Age,&entity.Birthdate,&entity.Email,&entity.Status,&entity.Uuid,
        &entity.Created,
        &entity.Updated,
    )
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, ErrNotFound
        }
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
        return nil, fmt.Errorf("failed to get User by ID: %w", err)
    }

    dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
    return &entity, nil
}




func (d *UserDAL) GetByEmail(ctx context.Context, email string) (*User, error) {
    if d.configProvider.BlockedReads("user") {
        return nil, ErrOperationBlocked
    }

    const operation = "get_by_email"
    dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

    // key would for example be: user_email:test@something.com, but in this case cache is only mapping email -> id
    cacheKey := fmt.Sprintf("user_email:%v", email)

    // Fetch from cache Email -> ID mapping
    val, found := d.cache.Get(cacheKey)
    if found {
        entityId, ok := val.(int64)
        if !ok {
            return nil, fmt.Errorf("UserDAL.GetByEmail: Cache returned wrong type; expected ID type")
        }

        dalCacheHitsCounter.WithLabelValues("user", operation).Inc()
        // return entity by that id
        return d.GetByID(ctx, entityId)
    }

    // Cache missed or error during fetching cached data
	dalCacheMissesCounter.WithLabelValues("user", operation).Inc()

	// Fallback to database if cache miss or decoding fails
	result, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.getByEmail(ctx, email)
	})

	if err != nil {
		return nil, err
	}
	entity := result.(*User)

	// Store in cache Email -> ID mapping
    dalCacheWritesCounter.WithLabelValues("user").Inc()
    d.cache.Set(cacheKey, entity.ID, time.Second*300)

    return entity, err
}

func (d *UserDAL) getByEmail(ctx context.Context, email string) (*User, error) {
    const operation = "get_by_email"
    dbStart := time.Now()

    query := `
        SELECT id, version, age, birthdate, email, status, uuid, created, updated
        FROM users
        WHERE email = ?
    `

    db, dbErr := d.dbProvider.GetDatabase("user", false);
    if dbErr != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
        return nil, dbErr
    }

    row := db.QueryRowContext(ctx, query, email)
    var entity User
    err := row.Scan(
        &entity.ID,
        &entity.version,
        &entity.Age,
        &entity.Birthdate,
        &entity.Email,
        &entity.Status,
        &entity.Uuid,
        &entity.Created,
        &entity.Updated,
    )
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, ErrNotFound
        }

        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
        return nil, fmt.Errorf("failed to get User by Email: %w", err)
    }

    dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
    return &entity, nil
}



func (d *UserDAL) GetByUuid(ctx context.Context, uuid string) (*User, error) {
    if d.configProvider.BlockedReads("user") {
        return nil, ErrOperationBlocked
    }

    const operation = "get_by_uuid"
    dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

    // key would for example be: user_email:test@something.com, but in this case cache is only mapping email -> id
    cacheKey := fmt.Sprintf("user_uuid:%v", uuid)

    // Fetch from cache Uuid -> ID mapping
    val, found := d.cache.Get(cacheKey)
    if found {
        entityId, ok := val.(int64)
        if !ok {
            return nil, fmt.Errorf("UserDAL.GetByUuid: Cache returned wrong type; expected ID type")
        }

        dalCacheHitsCounter.WithLabelValues("user", operation).Inc()
        // return entity by that id
        return d.GetByID(ctx, entityId)
    }

    // Cache missed or error during fetching cached data
	dalCacheMissesCounter.WithLabelValues("user", operation).Inc()

	// Fallback to database if cache miss or decoding fails
	result, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.getByUuid(ctx, uuid)
	})

	if err != nil {
		return nil, err
	}
	entity := result.(*User)

	// Store in cache Uuid -> ID mapping
    dalCacheWritesCounter.WithLabelValues("user").Inc()
    d.cache.Set(cacheKey, entity.ID, time.Second*300)

    return entity, err
}

func (d *UserDAL) getByUuid(ctx context.Context, uuid string) (*User, error) {
    const operation = "get_by_uuid"
    dbStart := time.Now()

    query := `
        SELECT id, version, age, birthdate, email, status, uuid, created, updated
        FROM users
        WHERE uuid = ?
    `

    db, dbErr := d.dbProvider.GetDatabase("user", false);
    if dbErr != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
        return nil, dbErr
    }

    row := db.QueryRowContext(ctx, query, uuid)
    var entity User
    err := row.Scan(
        &entity.ID,
        &entity.version,
        &entity.Age,
        &entity.Birthdate,
        &entity.Email,
        &entity.Status,
        &entity.Uuid,
        &entity.Created,
        &entity.Updated,
    )
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, ErrNotFound
        }

        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
        return nil, fmt.Errorf("failed to get User by Uuid: %w", err)
    }

    dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
    return &entity, nil
}



func (d *UserDAL) ListById(ctx context.Context, startID int64, pageSize int) ([]*User, error) {
    if d.configProvider.BlockedReads("user") {
        return nil, ErrOperationBlocked
    }

	const operation = "list_by_id"
	dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

    cacheKey := fmt.Sprintf("user_list_by_id:%d:%d", startID, pageSize)
    val, found := d.listCache.Get(cacheKey)
    if found {
        entityIDs, ok := val.([]int64)
        if !ok {
            return nil, fmt.Errorf("UserDAL.ListById: Cache returned wrong type; expected array ID type")
        }

        var entities []*User
        missingEntries := false
        for _, id := range entityIDs {
            entity, err := d.getByIDCached(id)
            if err != nil {
                // failed using cache
                return nil, err
            }

            if entity == nil {
                // we have one or more missing entity in cache somehow. reload the whole list.
                missingEntries = true
                break
            }

            entities = append(entities, entity)
        }

        if !missingEntries {
            dalCacheHitsCounter.WithLabelValues("user", operation).Inc()
            return entities, nil
        }
    }

    // Otherwise, it's a cache miss or decode error
    dalCacheMissesCounter.WithLabelValues("user", operation).Inc()

    // 2) Fallback to DB
    result, err := d.dbBreaker.Execute(func() (interface{}, error) {
        return d.listById(ctx, startID, pageSize)
    })

    if err != nil {
        // DB also failed
        return nil, err
    }

    entities := result.([]*User)
    // Store Cache. cacheKey = user_list_by_id:startID:pageSize.
	// Stored is array of entity IDs.
	var entityIDs []int64
	for _, entity := range entities {
		entityIDs = append(entityIDs, entity.ID)
        // cache each entity individualy
        d.setCached(entity)
	}
	d.listCache.Set(cacheKey, entityIDs, time.Second*60)

    return entities, nil
}

func (d *UserDAL) listById(ctx context.Context, startID int64, pageSize int) ([]*User, error) {
    const operation = "list_by_id"
	dbStart := time.Now()

    var query string

    // if startID is zero then query is different for pagination
    if startID == 0 {
        query = `SELECT id, version, age, birthdate, email, status, uuid, created, updated FROM users ORDER BY id LIMIT ?`
    } else {
        query = `SELECT id, version, age, birthdate, email, status, uuid, created, updated FROM users WHERE id > ? ORDER BY id LIMIT ?`
    }

    db, dbErr := d.dbProvider.GetDatabase("user", false);
    if dbErr != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
        return nil, dbErr
    }

    var rows *sql.Rows
    var err error

    if startID == 0 {
	    rows, err = db.QueryContext(ctx, query, pageSize)
    } else {
        rows, err = db.QueryContext(ctx, query, startID, pageSize)
    }

	if err != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return nil, fmt.Errorf("failed to query users: %w", err)
	}
	defer rows.Close()

	var entities []*User
	for rows.Next() {
		var entity User
		err := rows.Scan(
			&entity.ID,
            &entity.version,
            &entity.Age,
            &entity.Birthdate,
            &entity.Email,
            &entity.Status,
            &entity.Uuid,
            &entity.Created,
            &entity.Updated,
		)
		if err != nil {
            dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
			return nil, fmt.Errorf("failed to scan User: %w", err)
		}
		entities = append(entities, &entity)
	}

	if err = rows.Err(); err != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return nil, fmt.Errorf("rows error: %w", err)
	}

    dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
	return entities, nil
}



func (d *UserDAL) ListByBday(ctx context.Context, birthdate sql.NullTime, startID int64, pageSize int) ([]*User, error) {
    if d.configProvider.BlockedReads("user") {
        return nil, ErrOperationBlocked
    }

	const operation = "list_by_bday"
	dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

    cacheKey := fmt.Sprintf("user_list_by_bday:%v:%d:%d", birthdate, startID, pageSize)
    val, found := d.listCache.Get(cacheKey)
    if found {
        entityIDs, ok := val.([]int64)
        if !ok {
            return nil, fmt.Errorf("UserDAL.ListByBday: Cache returned wrong type; expected array ID type")
        }

        var entities []*User
        missingEntries := false
        for _, id := range entityIDs {
            entity, err := d.getByIDCached(id)
            if err != nil {
                // failed using cache
                return nil, err
            }

            if entity == nil {
                // we have one or more missing entity in cache somehow. reload the whole list.
                missingEntries = true
                break
            }

            entities = append(entities, entity)
        }

        if !missingEntries {
            dalCacheHitsCounter.WithLabelValues("user", operation).Inc()
            return entities, nil
        }
    }

    // Otherwise, it's a cache miss or decode error
    dalCacheMissesCounter.WithLabelValues("user", operation).Inc()

    // 2) Fallback to DB
    result, err := d.dbBreaker.Execute(func() (interface{}, error) {
        return d.listByBday(ctx, birthdate, startID, pageSize)
    })

    if err != nil {
        // DB also failed
        return nil, err
    }

    entities := result.([]*User)
    // Store Cache. cacheKey = user_list_by_id:startID:pageSize.
	// Stored is array of entity IDs.
	var entityIDs []int64
	for _, entity := range entities {
		entityIDs = append(entityIDs, entity.ID)
        // cache each entity individualy
        d.setCached(entity)
	}
	d.listCache.Set(cacheKey, entityIDs, time.Second*60)

    return entities, nil
}

func (d *UserDAL) listByBday(ctx context.Context, birthdate sql.NullTime, startID int64, pageSize int) ([]*User, error) {
    const operation = "list_by_bday"
	dbStart := time.Now()

    var query string

    // if startID is zero then query is different for pagination
    if startID == 0 {
        query = `SELECT id, version, age, birthdate, email, status, uuid, created, updated FROM users WHERE birthdate < ? ORDER BY birthdate DESC, id DESC LIMIT ?`
    } else {
        query = `SELECT id, version, age, birthdate, email, status, uuid, created, updated FROM users WHERE birthdate < ? AND id < ? ORDER BY birthdate DESC, id DESC LIMIT ?`
    }

    db, dbErr := d.dbProvider.GetDatabase("user", false);
    if dbErr != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
        return nil, dbErr
    }

    var rows *sql.Rows
    var err error

    if startID == 0 {
	    rows, err = db.QueryContext(ctx, query, birthdate, pageSize)
    } else {
        rows, err = db.QueryContext(ctx, query, birthdate, startID, pageSize)
    }

	if err != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return nil, fmt.Errorf("failed to query users: %w", err)
	}
	defer rows.Close()

	var entities []*User
	for rows.Next() {
		var entity User
		err := rows.Scan(
			&entity.ID,
            &entity.version,
            &entity.Age,
            &entity.Birthdate,
            &entity.Email,
            &entity.Status,
            &entity.Uuid,
            &entity.Created,
            &entity.Updated,
		)
		if err != nil {
            dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
			return nil, fmt.Errorf("failed to scan User: %w", err)
		}
		entities = append(entities, &entity)
	}

	if err = rows.Err(); err != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return nil, fmt.Errorf("rows error: %w", err)
	}

    dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
	return entities, nil
}



func (d *UserDAL) ListByAge(ctx context.Context, age int8, startID int64, pageSize int) ([]*User, error) {
    if d.configProvider.BlockedReads("user") {
        return nil, ErrOperationBlocked
    }

	const operation = "list_by_age"
	dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

    cacheKey := fmt.Sprintf("user_list_by_age:%v:%d:%d", age, startID, pageSize)
    val, found := d.listCache.Get(cacheKey)
    if found {
        entityIDs, ok := val.([]int64)
        if !ok {
            return nil, fmt.Errorf("UserDAL.ListByAge: Cache returned wrong type; expected array ID type")
        }

        var entities []*User
        missingEntries := false
        for _, id := range entityIDs {
            entity, err := d.getByIDCached(id)
            if err != nil {
                // failed using cache
                return nil, err
            }

            if entity == nil {
                // we have one or more missing entity in cache somehow. reload the whole list.
                missingEntries = true
                break
            }

            entities = append(entities, entity)
        }

        if !missingEntries {
            dalCacheHitsCounter.WithLabelValues("user", operation).Inc()
            return entities, nil
        }
    }

    // Otherwise, it's a cache miss or decode error
    dalCacheMissesCounter.WithLabelValues("user", operation).Inc()

    // 2) Fallback to DB
    result, err := d.dbBreaker.Execute(func() (interface{}, error) {
        return d.listByAge(ctx, age, startID, pageSize)
    })

    if err != nil {
        // DB also failed
        return nil, err
    }

    entities := result.([]*User)
    // Store Cache. cacheKey = user_list_by_id:startID:pageSize.
	// Stored is array of entity IDs.
	var entityIDs []int64
	for _, entity := range entities {
		entityIDs = append(entityIDs, entity.ID)
        // cache each entity individualy
        d.setCached(entity)
	}
	d.listCache.Set(cacheKey, entityIDs, time.Second*60)

    return entities, nil
}

func (d *UserDAL) listByAge(ctx context.Context, age int8, startID int64, pageSize int) ([]*User, error) {
    const operation = "list_by_age"
	dbStart := time.Now()

    var query string

    // if startID is zero then query is different for pagination
    if startID == 0 {
        query = `SELECT id, version, age, birthdate, email, status, uuid, created, updated FROM users WHERE age = ? ORDER BY created, id LIMIT ?`
    } else {
        query = `SELECT id, version, age, birthdate, email, status, uuid, created, updated FROM users WHERE age = ? AND id > ? ORDER BY created, id LIMIT ?`
    }

    db, dbErr := d.dbProvider.GetDatabase("user", false);
    if dbErr != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
        return nil, dbErr
    }

    var rows *sql.Rows
    var err error

    if startID == 0 {
	    rows, err = db.QueryContext(ctx, query, age, pageSize)
    } else {
        rows, err = db.QueryContext(ctx, query, age, startID, pageSize)
    }

	if err != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return nil, fmt.Errorf("failed to query users: %w", err)
	}
	defer rows.Close()

	var entities []*User
	for rows.Next() {
		var entity User
		err := rows.Scan(
			&entity.ID,
            &entity.version,
            &entity.Age,
            &entity.Birthdate,
            &entity.Email,
            &entity.Status,
            &entity.Uuid,
            &entity.Created,
            &entity.Updated,
		)
		if err != nil {
            dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
			return nil, fmt.Errorf("failed to scan User: %w", err)
		}
		entities = append(entities, &entity)
	}

	if err = rows.Err(); err != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return nil, fmt.Errorf("rows error: %w", err)
	}

    dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
	return entities, nil
}



func (d *UserDAL) ListByStatus(ctx context.Context, status sql.NullString, startID int64, pageSize int) ([]*User, error) {
    if d.configProvider.BlockedReads("user") {
        return nil, ErrOperationBlocked
    }

	const operation = "list_by_status"
	dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

    cacheKey := fmt.Sprintf("user_list_by_status:%v:%d:%d", status, startID, pageSize)
    val, found := d.listCache.Get(cacheKey)
    if found {
        entityIDs, ok := val.([]int64)
        if !ok {
            return nil, fmt.Errorf("UserDAL.ListByStatus: Cache returned wrong type; expected array ID type")
        }

        var entities []*User
        missingEntries := false
        for _, id := range entityIDs {
            entity, err := d.getByIDCached(id)
            if err != nil {
                // failed using cache
                return nil, err
            }

            if entity == nil {
                // we have one or more missing entity in cache somehow. reload the whole list.
                missingEntries = true
                break
            }

            entities = append(entities, entity)
        }

        if !missingEntries {
            dalCacheHitsCounter.WithLabelValues("user", operation).Inc()
            return entities, nil
        }
    }

    // Otherwise, it's a cache miss or decode error
    dalCacheMissesCounter.WithLabelValues("user", operation).Inc()

    // 2) Fallback to DB
    result, err := d.dbBreaker.Execute(func() (interface{}, error) {
        return d.listByStatus(ctx, status, startID, pageSize)
    })

    if err != nil {
        // DB also failed
        return nil, err
    }

    entities := result.([]*User)
    // Store Cache. cacheKey = user_list_by_id:startID:pageSize.
	// Stored is array of entity IDs.
	var entityIDs []int64
	for _, entity := range entities {
		entityIDs = append(entityIDs, entity.ID)
        // cache each entity individualy
        d.setCached(entity)
	}
	d.listCache.Set(cacheKey, entityIDs, time.Second*60)

    return entities, nil
}

func (d *UserDAL) listByStatus(ctx context.Context, status sql.NullString, startID int64, pageSize int) ([]*User, error) {
    const operation = "list_by_status"
	dbStart := time.Now()

    var query string

    // if startID is zero then query is different for pagination
    if startID == 0 {
        query = `SELECT id, version, age, birthdate, email, status, uuid, created, updated FROM users WHERE status = ? ORDER BY created, id LIMIT ?`
    } else {
        query = `SELECT id, version, age, birthdate, email, status, uuid, created, updated FROM users WHERE status = ? AND id > ? ORDER BY created, id LIMIT ?`
    }

    db, dbErr := d.dbProvider.GetDatabase("user", false);
    if dbErr != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
        return nil, dbErr
    }

    var rows *sql.Rows
    var err error

    if startID == 0 {
	    rows, err = db.QueryContext(ctx, query, status, pageSize)
    } else {
        rows, err = db.QueryContext(ctx, query, status, startID, pageSize)
    }

	if err != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return nil, fmt.Errorf("failed to query users: %w", err)
	}
	defer rows.Close()

	var entities []*User
	for rows.Next() {
		var entity User
		err := rows.Scan(
			&entity.ID,
            &entity.version,
            &entity.Age,
            &entity.Birthdate,
            &entity.Email,
            &entity.Status,
            &entity.Uuid,
            &entity.Created,
            &entity.Updated,
		)
		if err != nil {
            dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
			return nil, fmt.Errorf("failed to scan User: %w", err)
		}
		entities = append(entities, &entity)
	}

	if err = rows.Err(); err != nil {
        dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return nil, fmt.Errorf("rows error: %w", err)
	}

    dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
	return entities, nil
}



// Count function for the specific list
func (d *UserDAL) CountListById(ctx context.Context, ) (int64, error) {
	if d.configProvider.BlockedReads("user") {
		return 0, ErrOperationBlocked
	}

	const operation = "count_list_by_id"
	dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

	cacheKey := fmt.Sprintf("user_count_list_by_id", )
	val, found := d.countCache.Get(cacheKey)
	if found {
		count, ok := val.(int64)
		if !ok {
			return 0, fmt.Errorf("UserDAL.CountListById: Cache returned wrong type; expected int64")
		}

		dalCacheHitsCounter.WithLabelValues("user", operation).Inc()
		return count, nil
	}

	// Otherwise, it's a cache miss or decode error
	dalCacheMissesCounter.WithLabelValues("user", operation).Inc()

	// 2) Fallback to DB
	count, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.countListById(ctx, )
	})

	if err != nil {
		// DB also failed
		return 0, err
	}

	d.countCache.Set(cacheKey, count, time.Second*60)

	return count.(int64), nil
}

func (d *UserDAL) countListById(ctx context.Context, ) (int64, error) {
	const operation = "count_list_by_id"
	dbStart := time.Now()

	// if startID is zero then query is different for pagination
	query := `SELECT count(*) FROM users`

	db, dbErr := d.dbProvider.GetDatabase("user", false)
	if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return 0, dbErr
	}

	var err error
	var count int64

	row := db.QueryRowContext(ctx, query, )

	err = row.Scan(
		&count,
	)

	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return 0, fmt.Errorf("failed to query users: %w", err)
	}

	dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
	return count, nil
}



// Count function for the specific list
func (d *UserDAL) CountListByBday(ctx context.Context, birthdate sql.NullTime, ) (int64, error) {
	if d.configProvider.BlockedReads("user") {
		return 0, ErrOperationBlocked
	}

	const operation = "count_list_by_bday"
	dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

	cacheKey := fmt.Sprintf("user_count_list_by_bday:%v", birthdate, )
	val, found := d.countCache.Get(cacheKey)
	if found {
		count, ok := val.(int64)
		if !ok {
			return 0, fmt.Errorf("UserDAL.CountListByBday: Cache returned wrong type; expected int64")
		}

		dalCacheHitsCounter.WithLabelValues("user", operation).Inc()
		return count, nil
	}

	// Otherwise, it's a cache miss or decode error
	dalCacheMissesCounter.WithLabelValues("user", operation).Inc()

	// 2) Fallback to DB
	count, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.countListByBday(ctx, birthdate, )
	})

	if err != nil {
		// DB also failed
		return 0, err
	}

	d.countCache.Set(cacheKey, count, time.Second*60)

	return count.(int64), nil
}

func (d *UserDAL) countListByBday(ctx context.Context, birthdate sql.NullTime, ) (int64, error) {
	const operation = "count_list_by_bday"
	dbStart := time.Now()

	// if startID is zero then query is different for pagination
	query := `SELECT count(*) FROM users WHERE birthdate < ?`

	db, dbErr := d.dbProvider.GetDatabase("user", false)
	if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return 0, dbErr
	}

	var err error
	var count int64

	row := db.QueryRowContext(ctx, query, birthdate, )

	err = row.Scan(
		&count,
	)

	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return 0, fmt.Errorf("failed to query users: %w", err)
	}

	dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
	return count, nil
}



// Count function for the specific list
func (d *UserDAL) CountListByAge(ctx context.Context, age int8, ) (int64, error) {
	if d.configProvider.BlockedReads("user") {
		return 0, ErrOperationBlocked
	}

	const operation = "count_list_by_age"
	dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

	cacheKey := fmt.Sprintf("user_count_list_by_age:%v", age, )
	val, found := d.countCache.Get(cacheKey)
	if found {
		count, ok := val.(int64)
		if !ok {
			return 0, fmt.Errorf("UserDAL.CountListByAge: Cache returned wrong type; expected int64")
		}

		dalCacheHitsCounter.WithLabelValues("user", operation).Inc()
		return count, nil
	}

	// Otherwise, it's a cache miss or decode error
	dalCacheMissesCounter.WithLabelValues("user", operation).Inc()

	// 2) Fallback to DB
	count, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.countListByAge(ctx, age, )
	})

	if err != nil {
		// DB also failed
		return 0, err
	}

	d.countCache.Set(cacheKey, count, time.Second*60)

	return count.(int64), nil
}

func (d *UserDAL) countListByAge(ctx context.Context, age int8, ) (int64, error) {
	const operation = "count_list_by_age"
	dbStart := time.Now()

	// if startID is zero then query is different for pagination
	query := `SELECT count(*) FROM users WHERE age = ?`

	db, dbErr := d.dbProvider.GetDatabase("user", false)
	if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return 0, dbErr
	}

	var err error
	var count int64

	row := db.QueryRowContext(ctx, query, age, )

	err = row.Scan(
		&count,
	)

	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return 0, fmt.Errorf("failed to query users: %w", err)
	}

	dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
	return count, nil
}



// Count function for the specific list
func (d *UserDAL) CountListByStatus(ctx context.Context, status sql.NullString, ) (int64, error) {
	if d.configProvider.BlockedReads("user") {
		return 0, ErrOperationBlocked
	}

	const operation = "count_list_by_status"
	dalOperationsTotalCounter.WithLabelValues("user", operation).Inc()

	cacheKey := fmt.Sprintf("user_count_list_by_status:%v", status, )
	val, found := d.countCache.Get(cacheKey)
	if found {
		count, ok := val.(int64)
		if !ok {
			return 0, fmt.Errorf("UserDAL.CountListByStatus: Cache returned wrong type; expected int64")
		}

		dalCacheHitsCounter.WithLabelValues("user", operation).Inc()
		return count, nil
	}

	// Otherwise, it's a cache miss or decode error
	dalCacheMissesCounter.WithLabelValues("user", operation).Inc()

	// 2) Fallback to DB
	count, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.countListByStatus(ctx, status, )
	})

	if err != nil {
		// DB also failed
		return 0, err
	}

	d.countCache.Set(cacheKey, count, time.Second*60)

	return count.(int64), nil
}

func (d *UserDAL) countListByStatus(ctx context.Context, status sql.NullString, ) (int64, error) {
	const operation = "count_list_by_status"
	dbStart := time.Now()

	// if startID is zero then query is different for pagination
	query := `SELECT count(*) FROM users WHERE status = ?`

	db, dbErr := d.dbProvider.GetDatabase("user", false)
	if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return 0, dbErr
	}

	var err error
	var count int64

	row := db.QueryRowContext(ctx, query, status, )

	err = row.Scan(
		&count,
	)

	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("user", operation).Inc()
		return 0, fmt.Errorf("failed to query users: %w", err)
	}

	dbRequestsLatencyHistogram.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
	return count, nil
}

