/*
NOTE! This code is autogenerated.
Don't manually change this code.
Version [545815e97fb37cab651ffa9b0aa5b53269900274d17c376fb000355cdc7e3358]
*/
package dal

import (
    "context"
    "encoding/gob"
    "database/sql"
    "errors"
    "strings"

    "fmt"
    "time"

    "github.com/patrickmn/go-cache"
    "github.com/sony/gobreaker"
)

func init() {
	gob.Register(User{})
}


type Post struct {
    ID        int64
    version   int32
    
    Deleted bool `json:"deleted"`
    Post string `json:"post"`
    TargetAge int8 `json:"target_age"`

    Created   time.Time
    Updated   time.Time
}

type PostDAL struct {
    dbProvider          DBProvider
    cache               *cache.Cache  // Simple TTL cache for single items, for inmemory cache management
  	listCache           *cache.Cache // Cache for lists. Simple TTL cache, for inmemory cache management
    countCache          *cache.Cache // Cache for counts. Simple TTL cache, for inmemory cache management
    cacheProvider       CacheProvider
    configProvider      ConfigProvider
	dbBreaker           *gobreaker.CircuitBreaker
}

func NewPostDAL(provider DBProvider, cacheProvider CacheProvider,
    configProvider ConfigProvider, dbSettings gobreaker.Settings) *PostDAL {

    if configProvider == nil {
        configProvider = DefaultConfigProvider{}
    }

    if cacheProvider == nil {
        cacheProvider = NoopCacheProvider{}
    }

    if dbSettings.Name == "" {
        dbSettings.Name = "post_dal"
    }
    if dbSettings.ReadyToTrip == nil {
        dbSettings.ReadyToTrip = func(counts gobreaker.Counts) bool {
            return counts.ConsecutiveFailures > 5
        }
    }
    if dbSettings.OnStateChange == nil {
		dbSettings.OnStateChange = OnCircuitBreakerStateChange
	}

    if dbSettings.Timeout == 0 {
        dbSettings.Timeout = time.Second * 30
    }

    // Default expiration is 5 minutes and cleanup of 10 minutes
   	singleCache := cache.New(5*time.Minute, 10*time.Minute)
	listCache := cache.New(5*time.Minute, 10*time.Minute)
    countCache := cache.New(5*time.Minute, 10*time.Minute)

    newDAL := &PostDAL{
        dbProvider:     provider,
        cache:          singleCache,
        listCache:      listCache,
        countCache:     countCache,
        cacheProvider:  cacheProvider,
        configProvider: configProvider,
		dbBreaker:      gobreaker.NewCircuitBreaker(dbSettings),
    }

    // initialize cache invalidation handler
    cacheProvider.OnCacheInvalidated("post", newDAL.onCacheInvalidated)
    cacheProvider.OnCacheFlushList("post", newDAL.onCacheFlushList)

    return newDAL
}

func (d *PostDAL) getCacheKey(id int64) string {
    return fmt.Sprintf("post_id:%d", id)
}



func (d *PostDAL) InvalidateCache(entity *Post) {
    cacheKey := d.getCacheKey(entity.ID)
	d.cache.Delete(cacheKey)

	// Invalidate cache entry across instances
	d.cacheProvider.InvalidateCache("post", cacheKey)
}

func (d *PostDAL) FlushListCache() {
    d.listCache.Flush()
    d.countCache.Flush()

    // Invalidate cache entry across instances
    d.cacheProvider.FlushListCache("post")
}


// Handles cache invalidations. Just remove cached entry by key
func (d *PostDAL) onCacheInvalidated(key string) {
    d.cache.Delete(key)
}

// Handles cache_flush_list. Just clears all lists cache.
func (d *PostDAL) onCacheFlushList() {
    d.listCache.Flush()
    d.countCache.Flush()
}




func (d *PostDAL) Create(ctx context.Context, entity *Post) (*Post, error) {
    if d.configProvider.BlockedWrites("post") {
        return nil, ErrOperationBlocked
    }

	if entity.ID > 0 {
		return nil, fmt.Errorf("PostDAL.Create failed as ID > 0")
	}

	const operation = "create"
	dalOperationsTotalCounter.WithLabelValues("post", operation).Inc()

	_, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.create(ctx, entity)
	})

	if err != nil {
		return nil, err
	}

	d.setCached(entity)

	// All lists cache should be flushed.
	d.FlushListCache()

	return entity, err
}

func (d *PostDAL) create(ctx context.Context, entity *Post) (*Post, error) {
	const operation = "create"
	start := time.Now()

	entity.Created = time.Now()
	entity.Updated = time.Now()

	query := `
		INSERT INTO posts (deleted,post,target_age,
created,updated)
		VALUES (?,?,?,?,?)
	`

    db, dbErr := d.dbProvider.GetDatabase("post", true);
    if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
        return nil, dbErr
    }

	result, err := db.ExecContext(ctx, query,entity.Deleted, entity.Post, entity.TargetAge,
		entity.Created, entity.Updated)

	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return nil, fmt.Errorf("failed to insert Post: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return nil, fmt.Errorf("failed to get last insert ID: %w", err)
	}

	entity.ID = id
	dbRequestsLatencyHistogram.WithLabelValues("post", operation).Observe(time.Since(start).Seconds())
	return entity, nil
}



func (d *PostDAL) CreateBulk(ctx context.Context, entities []*Post) ([]*Post, error) {
	if d.configProvider.BlockedWrites("post") {
		return nil, ErrOperationBlocked
	}

	const operation = "create_bulk"
	dalOperationsTotalCounter.WithLabelValues("post", operation).Inc()

	result, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.createBulk(ctx, entities)
	})

	if err != nil {
		return nil, err
	}

	// All lists cache should be flushed.
	d.FlushListCache()

	return result.([]*Post), err
}

func (d *PostDAL) createBulk(ctx context.Context, entities []*Post) ([]*Post, error) {
	const operation = "create_bulk"
	start := time.Now()

	if len(entities) == 0 {
		return nil, fmt.Errorf("empty entities list")
	}

	// Prepare data and parameters
	valuePlaceholders := make([]string, 0, len(entities))
	params := make([]interface{}, 0, len(entities)*7) // 7 fields per entity
	now := time.Now()

	for _, entity := range entities {
		if entity.ID > 0 {
			return nil, fmt.Errorf("entity with existing ID in bulk create")
		}

		entity.Created = now
		entity.Updated = now

		valuePlaceholders = append(valuePlaceholders, "(?,?,?,?,?)")
		params = append(params,entity.Deleted,entity.Post,entity.TargetAge,
            entity.Created,
            entity.Updated,
		)
	}

	query := fmt.Sprintf(`
			INSERT INTO posts
			(deleted,post,target_age,
created,updated)
			VALUES %s
		`, strings.Join(valuePlaceholders, ","))

	db, dbErr := d.dbProvider.GetDatabase("post", true)
	if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return nil, dbErr
	}

	result, err := db.ExecContext(ctx, query, params...)
	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return nil, fmt.Errorf("failed to bulk insert posts: %w", err)
	}

	// Get generated IDs (works for MySQL/SQLite)
	lastID, err := result.LastInsertId()
	if err != nil {
		return nil, fmt.Errorf("failed to get last insert ID: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return nil, fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected != int64(len(entities)) {
		return nil, fmt.Errorf("mismatch between inserted rows and entity count")
	}

	// Assign generated IDs sequentially
	for i := range entities {
		entities[i].ID = lastID + int64(i)
	}

	dbRequestsLatencyHistogram.WithLabelValues("post", operation).Observe(time.Since(start).Seconds())
	return entities, nil
}



// ErrNotFound is returned in case there was nothing to update; either missing id or newer version of entity is already stored.
func (d *PostDAL) Update(ctx context.Context, entity *Post) error {
    if d.configProvider.BlockedWrites("post") {
        return ErrOperationBlocked
    }

	const operation = "update"
	dalOperationsTotalCounter.WithLabelValues("post", operation).Inc()

	

	// Perform the update in DB.
	_, err2 := d.dbBreaker.Execute(func() (interface{}, error) {
		return nil, d.update(ctx, entity)
	})

	if err2 != nil {
		return err2
	}

	

	// Lets clear item from cache on other instances and here
	d.InvalidateCache(entity)
	d.FlushListCache()

	entity.version++
	// our entity can become part of local cache
	d.setCached(entity)

	return nil
}

func (d *PostDAL) update(ctx context.Context, entity *Post) error {
	const operation = "update"
	start := time.Now()

	entity.Updated = time.Now()

	query := `
		UPDATE posts
		SET deleted = ?,post = ?,target_age = ?, updated=?, version = version + 1
		WHERE id = ? AND version = ?
	`

    db, dbErr := d.dbProvider.GetDatabase("post", true);
    if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
        return dbErr
    }

	res, err := db.ExecContext(ctx, query,entity.Deleted, entity.Post, entity.TargetAge,
	entity.Updated, entity.ID, entity.version)

	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return fmt.Errorf("failed to update Post: %w", err)
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		// clean out cache for specific ID to limit stale cache entries
		d.InvalidateCache(entity)
		return ErrNotFound
	}

	dbRequestsLatencyHistogram.WithLabelValues("post", operation).Observe(time.Since(start).Seconds())

	return nil
}



func (d *PostDAL) Store(ctx context.Context, entity *Post) (*Post, error) {
    if d.configProvider.BlockedWrites("post") {
        return nil, ErrOperationBlocked
    }

	const operation = "store"
	dalOperationsTotalCounter.WithLabelValues("post", operation).Inc()

	var result *Post
	var err error

	if entity.ID > 0 {
		// Update existing entity
		err = d.Update(ctx, entity)
		result = entity // Return the same entity after update
	} else {
		// Create new entity
		result, err = d.Create(ctx, entity)
	}

	// Handle errors
	if err != nil {
		return nil, err
	}

	return result, nil
}




// Deletes entity by id,
// returns ErrNotFound in case nothing is deleted.
func (d *PostDAL) Delete(ctx context.Context, entity *Post) error {
    if d.configProvider.BlockedWrites("post") {
        return ErrOperationBlocked
    }

	if entity.ID == 0 {
		// nothing can be deleted as entity is not created.
		return ErrNotFound
	}

	const operation = "delete"
	dalOperationsTotalCounter.WithLabelValues("post", operation).Inc()

	_, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return nil, d.delete(ctx, entity.ID)
	})

	if err != nil {
		return err
	}

	// Lets clear item from cache and on next use use DB as source of truth
	d.InvalidateCache(entity)
	d.FlushListCache()

	return err
}

func (d *PostDAL) delete(ctx context.Context, id int64) error {
	start := time.Now()
	const operation = "delete"

	query := `
		DELETE FROM posts
		WHERE id = ?
	`

    db, dbErr := d.dbProvider.GetDatabase("post", true);
    if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
        return dbErr
    }

	res, err := db.ExecContext(ctx, query, id)
	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return fmt.Errorf("failed to delete post: %w", err)
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return ErrNotFound
	}

	dbRequestsLatencyHistogram.WithLabelValues("post", operation).Observe(time.Since(start).Seconds())
	return nil
}




func (d *PostDAL) GetByID(ctx context.Context, id int64) (*Post, error) {
    if d.configProvider.BlockedReads("post") {
        return nil, ErrOperationBlocked
    }

    const operation = "get_by_id"
    dalOperationsTotalCounter.WithLabelValues("post", operation).Inc()

	// Load from cache
    cachedEntity, _ := d.getByIDCached(id)
    if cachedEntity != nil {
        return cachedEntity, nil
    }

	// Fallback to database if cache miss or decoding fails
	result, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.getByID(ctx, id)
	})

	if err != nil {
		return nil, err
	}

	entity, ok := result.(*Post)
    if !ok {
        return nil, fmt.Errorf("invalid type")
    }

    _ = d.setCached(entity)

    return entity, err
}

func (d *PostDAL) setCached(entity *Post) error {
    // if we have not reached the maximum number of items set the cache. otherwise expirations will
	// handle this
    itemCount := d.cache.ItemCount()
    if itemCount < 1000000 {
        cacheKey := d.getCacheKey(entity.ID)

        // Store in cache with new format
        dalCacheWritesCounter.WithLabelValues("post").Inc()
        dalCacheSizeGauge.WithLabelValues("post").Set(float64(itemCount+1))

        copy := *entity
		d.cache.Set(cacheKey, &copy, time.Second*300)
    }

    return nil
}

// Gets entity from cache only or return nil
func (d *PostDAL) getByIDCached(id int64) (*Post, error) {
    const operation = "get_by_id"
    cacheKey := d.getCacheKey(id)
    val, found := d.cache.Get(cacheKey)
    if found {
        entity, ok := val.(*Post)
        if !ok {
            return nil, fmt.Errorf("PostDAL.GetById: Cache returned wrong type")
        }

        dalCacheHitsCounter.WithLabelValues("post", operation).Inc()
        copy := *entity
        return &copy, nil
    }

    // Cache missed or error during fetching cached data
	dalCacheMissesCounter.WithLabelValues("post", operation).Inc()

    return nil, nil
}

func (d *PostDAL) getByID(ctx context.Context, id int64) (*Post, error) {
    const operation = "get_by_id"
    dbStart := time.Now();

    query := `
        SELECT id, version, deleted, post, target_age, created, updated
        FROM posts
        WHERE id = ?
    `

    db, dbErr := d.dbProvider.GetDatabase("post", false);
    if dbErr != nil {
        dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
        return nil, dbErr
    }

    row := db.QueryRowContext(ctx, query, id)
    var entity Post
    err := row.Scan(
        &entity.ID,
        &entity.version,&entity.Deleted,&entity.Post,&entity.TargetAge,
        &entity.Created,
        &entity.Updated,
    )
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, ErrNotFound
        }
        dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
        return nil, fmt.Errorf("failed to get Post by ID: %w", err)
    }

    dbRequestsLatencyHistogram.WithLabelValues("post", operation).Observe(time.Since(dbStart).Seconds())
    return &entity, nil
}




func (d *PostDAL) ListById(ctx context.Context, startID int64, pageSize int) ([]*Post, error) {
    if d.configProvider.BlockedReads("post") {
        return nil, ErrOperationBlocked
    }

	const operation = "list_by_id"
	dalOperationsTotalCounter.WithLabelValues("post", operation).Inc()

    cacheKey := fmt.Sprintf("post_list_by_id:%d:%d", startID, pageSize)
    val, found := d.listCache.Get(cacheKey)
    if found {
        entityIDs, ok := val.([]int64)
        if !ok {
            return nil, fmt.Errorf("PostDAL.ListById: Cache returned wrong type; expected array ID type")
        }

        var entities []*Post
        missingEntries := false
        for _, id := range entityIDs {
            entity, err := d.getByIDCached(id)
            if err != nil {
                // failed using cache
                return nil, err
            }

            if entity == nil {
                // we have one or more missing entity in cache somehow. reload the whole list.
                missingEntries = true
                break
            }

            entities = append(entities, entity)
        }

        if !missingEntries {
            dalCacheHitsCounter.WithLabelValues("post", operation).Inc()
            return entities, nil
        }
    }

    // Otherwise, it's a cache miss or decode error
    dalCacheMissesCounter.WithLabelValues("post", operation).Inc()

    // 2) Fallback to DB
    result, err := d.dbBreaker.Execute(func() (interface{}, error) {
        return d.listById(ctx, startID, pageSize)
    })

    if err != nil {
        // DB also failed
        return nil, err
    }

    entities := result.([]*Post)
    // Store Cache. cacheKey = user_list_by_id:startID:pageSize.
	// Stored is array of entity IDs.
	var entityIDs []int64
	for _, entity := range entities {
		entityIDs = append(entityIDs, entity.ID)
        // cache each entity individualy
        d.setCached(entity)
	}
	d.listCache.Set(cacheKey, entityIDs, time.Second*60)

    return entities, nil
}

func (d *PostDAL) listById(ctx context.Context, startID int64, pageSize int) ([]*Post, error) {
    const operation = "list_by_id"
	dbStart := time.Now()

    var query string

    // if startID is zero then query is different for pagination
    if startID == 0 {
        query = `SELECT id, version, deleted, post, target_age, created, updated FROM posts ORDER BY id LIMIT ?`
    } else {
        query = `SELECT id, version, deleted, post, target_age, created, updated FROM posts WHERE id > ? ORDER BY id LIMIT ?`
    }

    db, dbErr := d.dbProvider.GetDatabase("post", false);
    if dbErr != nil {
        dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
        return nil, dbErr
    }

    var rows *sql.Rows
    var err error

    if startID == 0 {
	    rows, err = db.QueryContext(ctx, query, pageSize)
    } else {
        rows, err = db.QueryContext(ctx, query, startID, pageSize)
    }

	if err != nil {
        dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return nil, fmt.Errorf("failed to query posts: %w", err)
	}
	defer rows.Close()

	var entities []*Post
	for rows.Next() {
		var entity Post
		err := rows.Scan(
			&entity.ID,
            &entity.version,
            &entity.Deleted,
            &entity.Post,
            &entity.TargetAge,
            &entity.Created,
            &entity.Updated,
		)
		if err != nil {
            dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
			return nil, fmt.Errorf("failed to scan Post: %w", err)
		}
		entities = append(entities, &entity)
	}

	if err = rows.Err(); err != nil {
        dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return nil, fmt.Errorf("rows error: %w", err)
	}

    dbRequestsLatencyHistogram.WithLabelValues("post", operation).Observe(time.Since(dbStart).Seconds())
	return entities, nil
}



func (d *PostDAL) RecentPosts(ctx context.Context, targetAge int8, startID int64, pageSize int) ([]*Post, error) {
    if d.configProvider.BlockedReads("post") {
        return nil, ErrOperationBlocked
    }

	const operation = "recent_posts"
	dalOperationsTotalCounter.WithLabelValues("post", operation).Inc()

    cacheKey := fmt.Sprintf("post_recent_posts:%v:%d:%d", targetAge, startID, pageSize)
    val, found := d.listCache.Get(cacheKey)
    if found {
        entityIDs, ok := val.([]int64)
        if !ok {
            return nil, fmt.Errorf("PostDAL.RecentPosts: Cache returned wrong type; expected array ID type")
        }

        var entities []*Post
        missingEntries := false
        for _, id := range entityIDs {
            entity, err := d.getByIDCached(id)
            if err != nil {
                // failed using cache
                return nil, err
            }

            if entity == nil {
                // we have one or more missing entity in cache somehow. reload the whole list.
                missingEntries = true
                break
            }

            entities = append(entities, entity)
        }

        if !missingEntries {
            dalCacheHitsCounter.WithLabelValues("post", operation).Inc()
            return entities, nil
        }
    }

    // Otherwise, it's a cache miss or decode error
    dalCacheMissesCounter.WithLabelValues("post", operation).Inc()

    // 2) Fallback to DB
    result, err := d.dbBreaker.Execute(func() (interface{}, error) {
        return d.recentPosts(ctx, targetAge, startID, pageSize)
    })

    if err != nil {
        // DB also failed
        return nil, err
    }

    entities := result.([]*Post)
    // Store Cache. cacheKey = user_list_by_id:startID:pageSize.
	// Stored is array of entity IDs.
	var entityIDs []int64
	for _, entity := range entities {
		entityIDs = append(entityIDs, entity.ID)
        // cache each entity individualy
        d.setCached(entity)
	}
	d.listCache.Set(cacheKey, entityIDs, time.Second*60)

    return entities, nil
}

func (d *PostDAL) recentPosts(ctx context.Context, targetAge int8, startID int64, pageSize int) ([]*Post, error) {
    const operation = "recent_posts"
	dbStart := time.Now()

    var query string

    // if startID is zero then query is different for pagination
    if startID == 0 {
        query = `SELECT id, version, deleted, post, target_age, created, updated FROM posts WHERE deleted = 0 and target_age = ? ORDER BY created, id LIMIT ?`
    } else {
        query = `SELECT id, version, deleted, post, target_age, created, updated FROM posts WHERE deleted = 0 and target_age = ? AND id > ? ORDER BY created, id LIMIT ?`
    }

    db, dbErr := d.dbProvider.GetDatabase("post", false);
    if dbErr != nil {
        dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
        return nil, dbErr
    }

    var rows *sql.Rows
    var err error

    if startID == 0 {
	    rows, err = db.QueryContext(ctx, query, targetAge, pageSize)
    } else {
        rows, err = db.QueryContext(ctx, query, targetAge, startID, pageSize)
    }

	if err != nil {
        dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return nil, fmt.Errorf("failed to query posts: %w", err)
	}
	defer rows.Close()

	var entities []*Post
	for rows.Next() {
		var entity Post
		err := rows.Scan(
			&entity.ID,
            &entity.version,
            &entity.Deleted,
            &entity.Post,
            &entity.TargetAge,
            &entity.Created,
            &entity.Updated,
		)
		if err != nil {
            dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
			return nil, fmt.Errorf("failed to scan Post: %w", err)
		}
		entities = append(entities, &entity)
	}

	if err = rows.Err(); err != nil {
        dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return nil, fmt.Errorf("rows error: %w", err)
	}

    dbRequestsLatencyHistogram.WithLabelValues("post", operation).Observe(time.Since(dbStart).Seconds())
	return entities, nil
}



// Count function for the specific list
func (d *PostDAL) CountListById(ctx context.Context, ) (int64, error) {
	if d.configProvider.BlockedReads("post") {
		return 0, ErrOperationBlocked
	}

	const operation = "count_list_by_id"
	dalOperationsTotalCounter.WithLabelValues("post", operation).Inc()

	cacheKey := fmt.Sprintf("post_count_list_by_id", )
	val, found := d.countCache.Get(cacheKey)
	if found {
		count, ok := val.(int64)
		if !ok {
			return 0, fmt.Errorf("PostDAL.CountListById: Cache returned wrong type; expected int64")
		}

		dalCacheHitsCounter.WithLabelValues("post", operation).Inc()
		return count, nil
	}

	// Otherwise, it's a cache miss or decode error
	dalCacheMissesCounter.WithLabelValues("post", operation).Inc()

	// 2) Fallback to DB
	count, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.countListById(ctx, )
	})

	if err != nil {
		// DB also failed
		return 0, err
	}

	d.countCache.Set(cacheKey, count, time.Second*60)

	return count.(int64), nil
}

func (d *PostDAL) countListById(ctx context.Context, ) (int64, error) {
	const operation = "count_list_by_id"
	dbStart := time.Now()

	// if startID is zero then query is different for pagination
	query := `SELECT count(*) FROM posts`

	db, dbErr := d.dbProvider.GetDatabase("post", false)
	if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return 0, dbErr
	}

	var err error
	var count int64

	row := db.QueryRowContext(ctx, query, )

	err = row.Scan(
		&count,
	)

	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return 0, fmt.Errorf("failed to query posts: %w", err)
	}

	dbRequestsLatencyHistogram.WithLabelValues("post", operation).Observe(time.Since(dbStart).Seconds())
	return count, nil
}



// Count function for the specific list
func (d *PostDAL) CountRecentPosts(ctx context.Context, targetAge int8, ) (int64, error) {
	if d.configProvider.BlockedReads("post") {
		return 0, ErrOperationBlocked
	}

	const operation = "count_recent_posts"
	dalOperationsTotalCounter.WithLabelValues("post", operation).Inc()

	cacheKey := fmt.Sprintf("post_count_recent_posts:%v", targetAge, )
	val, found := d.countCache.Get(cacheKey)
	if found {
		count, ok := val.(int64)
		if !ok {
			return 0, fmt.Errorf("PostDAL.CountRecentPosts: Cache returned wrong type; expected int64")
		}

		dalCacheHitsCounter.WithLabelValues("post", operation).Inc()
		return count, nil
	}

	// Otherwise, it's a cache miss or decode error
	dalCacheMissesCounter.WithLabelValues("post", operation).Inc()

	// 2) Fallback to DB
	count, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.countRecentPosts(ctx, targetAge, )
	})

	if err != nil {
		// DB also failed
		return 0, err
	}

	d.countCache.Set(cacheKey, count, time.Second*60)

	return count.(int64), nil
}

func (d *PostDAL) countRecentPosts(ctx context.Context, targetAge int8, ) (int64, error) {
	const operation = "count_recent_posts"
	dbStart := time.Now()

	// if startID is zero then query is different for pagination
	query := `SELECT count(*) FROM posts WHERE deleted = 0 and target_age = ?`

	db, dbErr := d.dbProvider.GetDatabase("post", false)
	if dbErr != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return 0, dbErr
	}

	var err error
	var count int64

	row := db.QueryRowContext(ctx, query, targetAge, )

	err = row.Scan(
		&count,
	)

	if err != nil {
		dbRequestsErrorsCounter.WithLabelValues("post", operation).Inc()
		return 0, fmt.Errorf("failed to query posts: %w", err)
	}

	dbRequestsLatencyHistogram.WithLabelValues("post", operation).Observe(time.Since(dbStart).Seconds())
	return count, nil
}

