/**
  NOTE! This code is autogenerated.
  Don't manually change this code.
*/
package dal

import (
    "bytes"
    "context"
    "encoding/gob"
    "database/sql"
    "errors"

    "fmt"
    "time"

    "github.com/redis/go-redis/v9"
    "github.com/prometheus/client_golang/prometheus"
    "github.com/sony/gobreaker"
)

var (
    ErrNotFound = errors.New("user not found")

    dalOperationsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "dal_operations_total",
            Help: "Total number of DAL operation requests",
        },
        []string{"entity", "operation"},
    )

    dbRequestsErrors = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "db_requests_errors_total",
            Help: "Total number of failed DB requests",
        },
        []string{"entity", "operation"},
    )

    dbRequestsLatency = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "db_requests_latency_seconds",
            Help:    "Latency distribution of DB requests",
            Buckets: prometheus.DefBuckets,
        },
        []string{"entity", "operation"},
    )

    dalCacheWrites = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "dal_cache_writes_total",
			Help: "Total number of DAL cache writes",
		},
		[]string{"entity", "operation"},
	)
    dalCacheDeletes = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "dal_cache_deletes_total",
			Help: "Total number of DAL cache removals (invalidations)",
		},
		[]string{"entity"},
	)
    dalCacheHits = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "dal_cache_hits_total",
			Help: "Total number of DAL cache hits",
		},
		[]string{"entity", "operation"},
	)
    dalCacheErrors = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "dal_cache_errors_total",
			Help: "Total number of DAL cache errors",
		},
		[]string{"entity", "operation"},
	)
	dalCacheMisses = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "dal_cache_misses_total",
			Help: "Total number of DAL cache misses",
		},
		[]string{"entity", "operation"},
	)
	dalCacheLatency = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "dal_cache_latency_seconds",
			Help:    "Latency distribution of DAL cache operations",
			Buckets: prometheus.DefBuckets,
		},
		[]string{"entity", "operation"},
	)
)

func init() {
    prometheus.MustRegister(dalOperationsTotal, dbRequestsErrors, dbRequestsLatency)
   	prometheus.MustRegister(dalCacheHits, dalCacheMisses, dalCacheLatency, dalCacheWrites, dalCacheErrors, dalCacheDeletes)
	gob.Register(User{})
}


type User struct {
    ID        int64
    
    Age int8 `json:"age"`
    Birthdate sql.NullTime `json:"birthdate"`
    Email string `json:"email"`

    Created   time.Time
    Updated   time.Time
}

type UserDAL struct {
    db      *sql.DB
    cache       *redis.Client
	dbBreaker   *gobreaker.CircuitBreaker
	cacheBreaker *gobreaker.CircuitBreaker
}

func NewUserDAL(db *sql.DB, cache *redis.Client, dbSettings, cacheSettings gobreaker.Settings) *UserDAL {
    if dbSettings.Name == "" {
        dbSettings.Name = "user_dal"
    }
    if dbSettings.ReadyToTrip == nil {
        dbSettings.ReadyToTrip = func(counts gobreaker.Counts) bool {
            return counts.ConsecutiveFailures > 5
        }
    }
    if dbSettings.Timeout == 0 {
        dbSettings.Timeout = time.Second * 30
    }

    if cacheSettings.Name == "" {
		cacheSettings.Name = "user_dal_cache"
	}
	if cacheSettings.ReadyToTrip == nil {
		cacheSettings.ReadyToTrip = func(counts gobreaker.Counts) bool {
			return counts.ConsecutiveFailures > 3
		}
	}
	if cacheSettings.Timeout == 0 {
		cacheSettings.Timeout = time.Second * 10
	}

    return &UserDAL{
        db:      db,
        cache:        cache,
		dbBreaker:    gobreaker.NewCircuitBreaker(dbSettings),
		cacheBreaker: gobreaker.NewCircuitBreaker(cacheSettings),
    }
}



func (d *UserDAL) GetByID(ctx context.Context, id int64) (*User, error) {
    const operation = "get_by_id"
    cacheStart := time.Now()
    dalOperationsTotal.WithLabelValues("user", operation).Inc()

    cacheKey := fmt.Sprintf("user_id_v1:%d", id) // Versioning cache key

    var entity User
	result, err := d.cacheBreaker.Execute(func() (interface{}, error) {
		cachedData, err := d.cache.Get(ctx, cacheKey).Bytes()
		if err != nil {
            dalCacheErrors.WithLabelValues("user", operation).Inc()
			return nil, err
		}

		dec := gob.NewDecoder(bytes.NewReader(cachedData))
		err = dec.Decode(&entity)
        if err != nil {
            return nil, errors.New("cache decode error")
		}

        dalCacheHits.WithLabelValues("user", operation).Inc()
        return &entity, nil
	})

    // we got data from cache.
	if err == nil {
        dalCacheLatency.WithLabelValues("user", operation).Observe(time.Since(cacheStart).Seconds())
		return result.(*User), nil
	}

    // Cache missed or error during fetching cached data
	dalCacheMisses.WithLabelValues("user", operation).Inc()
    dbStart := time.Now();

	// Fallback to database if cache miss or decoding fails
	result, err = d.dbBreaker.Execute(func() (interface{}, error) {
		return d.getByID(ctx, id)
	})

	if err != nil {
        dbRequestsErrors.WithLabelValues("user", operation).Inc()
		return nil, err
	}
	entity = *result.(*User)

	// Store in cache with new format
	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	if enc.Encode(entity) == nil {
        dalCacheWrites.WithLabelValues("user", operation).Inc()
		d.cache.Set(ctx, cacheKey, buf.Bytes(), time.Minute*300)
	}

    dbRequestsLatency.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
    return result.(*User), err
}

func (d *UserDAL) getByID(ctx context.Context, id int64) (*User, error) {
    query := `
        SELECT id, age, birthdate, email, created, updated
        FROM users
        WHERE id = ?
    `

    row := d.db.QueryRowContext(ctx, query, id)
    var entity User
    err := row.Scan(
        &entity.ID,
        &entity.Age,
        &entity.Birthdate,
        &entity.Email,
        &entity.Created,
        &entity.Updated,
    )
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, ErrNotFound
        }
        return nil, fmt.Errorf("failed to get User by ID: %w", err)
    }
    return &entity, nil
}



func (d *UserDAL) InvalidateCache(ctx context.Context, entity *User) {
    d.cache.Del(ctx, fmt.Sprintf("User_id_v1:%d", entity.ID))
    d.cache.Del(ctx, fmt.Sprintf("User_email_v1:%d", entity.Email))
    d.invalidateListByID(ctx, entity.ID)
    d.invalidateListByAge(ctx, entity.Age)
    dalCacheDeletes.WithLabelValues("user").Inc()
}

func (d *UserDAL) invalidateListByID(ctx context.Context, id int64) {
    pattern := fmt.Sprintf("user_list_v1:id:*", id)

    var cursor uint64
    for {
        var keys []string
        var err error
        keys, cursor, err = d.cache.Scan(ctx, cursor, pattern, 1000).Result()
        if err != nil {
            // handle error
            break
        }
        if len(keys) > 0 {
            d.cache.Del(ctx, keys...)
        }
        if cursor == 0 {
            break
        }
    }
}
func (d *UserDAL) invalidateListByAge(ctx context.Context, age int8) {
    pattern := fmt.Sprintf("user_list_v1:age_%d:*", age)

    var cursor uint64
    for {
        var keys []string
        var err error
        keys, cursor, err = d.cache.Scan(ctx, cursor, pattern, 1000).Result()
        if err != nil {
            // handle error
            break
        }
        if len(keys) > 0 {
            d.cache.Del(ctx, keys...)
        }
        if cursor == 0 {
            break
        }
    }
}


/* Custom Get operations */
        
func (d *UserDAL) GetByEmail(ctx context.Context, email string) (*User, error) {
const operation = "get_by_email"
    cacheStart := time.Now()
    dalOperationsTotal.WithLabelValues("user", operation).Inc()

    cacheKey := fmt.Sprintf("user_email_v1:%d", email) // Versioning cache key

    var entity User
	result, err := d.cacheBreaker.Execute(func() (interface{}, error) {
		cachedData, err := d.cache.Get(ctx, cacheKey).Bytes()
		if err != nil {
            dalCacheErrors.WithLabelValues("user", operation).Inc()
			return nil, err
		}

		dec := gob.NewDecoder(bytes.NewReader(cachedData))
		err = dec.Decode(&entity)
        if err != nil {
            return nil, errors.New("cache decode error")
		}

        dalCacheHits.WithLabelValues("user", operation).Inc()
        return &entity, nil
	})

    // we got data from cache.
	if err == nil {
        dalCacheLatency.WithLabelValues("user", operation).Observe(time.Since(cacheStart).Seconds())
		return result.(*User), nil
	}

    // Cache missed or error during fetching cached data
	dalCacheMisses.WithLabelValues("user", operation).Inc()
    dbStart := time.Now();

	// Fallback to database if cache miss or decoding fails
	result, err = d.dbBreaker.Execute(func() (interface{}, error) {
		return d.getByEmail(ctx, email)
	})

	if err != nil {
        dbRequestsErrors.WithLabelValues("user", operation).Inc()
		return nil, err
	}
	entity = *result.(*User)

	// Store in cache with new format
	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	if enc.Encode(entity) == nil {
        dalCacheWrites.WithLabelValues("user", operation).Inc()
		d.cache.Set(ctx, cacheKey, buf.Bytes(), time.Minute*300)
	}

    dbRequestsLatency.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
    return result.(*User), err

}

func (d *UserDAL) getByEmail(ctx context.Context, email string) (*User, error) {
    query := `
        SELECT id, age, birthdate, email, created, updated
        FROM users
        WHERE email = ?
    `

    row := d.db.QueryRowContext(ctx, query, email)
    var entity User
    err := row.Scan(
        &entity.ID,
        &entity.Age,
        &entity.Birthdate,
        &entity.Email,
        &entity.Created,
        &entity.Updated,
    )
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, ErrNotFound
        }
        return nil, fmt.Errorf("failed to get User by Email: %w", err)
    }
    return &entity, nil
}

/* Custom Lists operations */
            
func (d *UserDAL) ListById(ctx context.Context, startID int64, pageSize int) ([]*User, error) {
	const operation = "list_by_id"
	cacheStart := time.Now()
	dalOperationsTotal.WithLabelValues("user", operation).Inc()

	// 1) Try Cache First
    entities, cacheErr := d.listByIdRedis(ctx, operation, startID, pageSize)
    if cacheErr == nil {
        // We got cache HIT
        dalCacheHits.WithLabelValues("user", operation).Inc()
        dalCacheLatency.WithLabelValues("user", operation).Observe(time.Since(cacheStart).Seconds())
        return entities, nil
    }

    // Otherwise, it's a cache miss or decode error
    dalCacheMisses.WithLabelValues("user", operation).Inc()

    // 2) Fallback to DB
	dbStart := time.Now();

    result, err := d.dbBreaker.Execute(func() (interface{}, error) {
        return d.listById(ctx, startID, pageSize)
    })
    if err != nil {
        // DB also failed
		dbRequestsErrors.WithLabelValues("user", operation).Inc()
        return nil, err
    }

    entities = result.([]*User)

    // 3) Store fresh data in Redis
    var buf bytes.Buffer
    enc := gob.NewEncoder(&buf)
    if enc.Encode(entities) == nil {
        // Short TTL for lists
		 dalCacheWrites.WithLabelValues("user", operation).Inc()
        _ = d.cache.Set(ctx, d.listByIdCacheKey(startID, pageSize), buf.Bytes(), time.Minute*60)
    }

    dbRequestsLatency.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
    return entities, nil
}


// listByIdRedis attempts to retrieve and decode the list from Redis using the cache circuit breaker.
func (d *UserDAL) listByIdRedis(
    ctx context.Context,
    operation string,
    startID int64,
    pageSize int,
) ([]*User, error) {
    // 1) Build cache key
    cacheKey := d.listByIdCacheKey(startID, pageSize)

    // 2) Use the cache circuit breaker
    result, err := d.cacheBreaker.Execute(func() (interface{}, error) {
        // Try getting data from Redis
        cachedData, redisErr := d.cache.Get(ctx, cacheKey).Bytes()
        if redisErr != nil {
            return nil, redisErr
        }

        var entities []*User
        dec := gob.NewDecoder(bytes.NewReader(cachedData))
        if decodeErr := dec.Decode(&entities); decodeErr != nil {
            return nil, errors.New("cache decode error")
        }

        return entities, nil
    })
    if err != nil {
        // Could be redis.Nil (key not found), decode error, or circuit open
        return nil, err
    }

    // Cache success → return data
    return result.([]*User), nil
}

// Helper to build the cache key
func (d *UserDAL) listByIdCacheKey(startID int64, pageSize int) string {
    return fmt.Sprintf("user_list_v1:id:start_%d:size_%d", startID, pageSize)
}

func (d *UserDAL) listById(ctx context.Context, startID int64, pageSize int) ([]*User, error) {
	query := `
		SELECT id, age, birthdate, email, created, updated
		FROM users
		WHERE id >= ?
		ORDER BY id ASC
		LIMIT ?
	`
	rows, err := d.db.QueryContext(ctx, query, startID, pageSize)
	if err != nil {
		return nil, fmt.Errorf("failed to query users: %w", err)
	}
	defer rows.Close()

	var entities []*User
	for rows.Next() {
	    var entity User
		err := rows.Scan(
			&entity.ID,
            &entity.Age,
            &entity.Birthdate,
            &entity.Email,
            &entity.Created,
            &entity.Updated,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan User: %w", err)
		}
		entities = append(entities, &entity)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return entities, nil
}

            
func (d *UserDAL) ListByAge(ctx context.Context, age int8, startID int64, pageSize int) ([]*User, error) {
	const operation = "list_by_age"
	cacheStart := time.Now()
	dalOperationsTotal.WithLabelValues("user", operation).Inc()

	// 1) Try Cache First
    entities, cacheErr := d.listByAgeRedis(ctx, operation, age, startID, pageSize)
    if cacheErr == nil {
        // We got cache HIT
        dalCacheHits.WithLabelValues("user", operation).Inc()
        dalCacheLatency.WithLabelValues("user", operation).Observe(time.Since(cacheStart).Seconds())
        return entities, nil
    }

    // Otherwise, it's a cache miss or decode error
    dalCacheMisses.WithLabelValues("user", operation).Inc()

    // 2) Fallback to DB
	dbStart := time.Now();

    result, err := d.dbBreaker.Execute(func() (interface{}, error) {
        return d.listByAge(ctx, age, startID, pageSize)
    })
    if err != nil {
        // DB also failed
		dbRequestsErrors.WithLabelValues("user", operation).Inc()
        return nil, err
    }

    entities = result.([]*User)

    // 3) Store fresh data in Redis
    var buf bytes.Buffer
    enc := gob.NewEncoder(&buf)
    if enc.Encode(entities) == nil {
        // Short TTL for lists
		 dalCacheWrites.WithLabelValues("user", operation).Inc()
        _ = d.cache.Set(ctx, d.listByAgeCacheKey(age, startID, pageSize), buf.Bytes(), time.Minute*60)
    }

    dbRequestsLatency.WithLabelValues("user", operation).Observe(time.Since(dbStart).Seconds())
    return entities, nil
}

// listByAgeRedis attempts to retrieve and decode the list from Redis using the cache circuit breaker.
func (d *UserDAL) listByAgeRedis(
    ctx context.Context,
    operation string,
    age int8,
    startID int64,
    pageSize int,
) ([]*User, error) {
    // 1) Build cache key
    cacheKey := d.listByAgeCacheKey(age, startID, pageSize)

    // 2) Use the cache circuit breaker
    result, err := d.cacheBreaker.Execute(func() (interface{}, error) {
        // Try getting data from Redis
        cachedData, redisErr := d.cache.Get(ctx, cacheKey).Bytes()
        if redisErr != nil {
            return nil, redisErr
        }

        var entities []*User
        dec := gob.NewDecoder(bytes.NewReader(cachedData))
        if decodeErr := dec.Decode(&entities); decodeErr != nil {
            return nil, errors.New("cache decode error")
        }

        return entities, nil
    })
    if err != nil {
        // Could be redis.Nil (key not found), decode error, or circuit open
        return nil, err
    }

    // Cache success → return data
    return result.([]*User), nil
}

// Helper to build the cache key
func (d *UserDAL) listByAgeCacheKey(age int8, startID int64, pageSize int) string {
    return fmt.Sprintf("user_list_v1:age_%v:start_%d:size_%d", age, startID, pageSize)
}

func (d *UserDAL) listByAge(ctx context.Context, age int8, startID int64, pageSize int) ([]*User, error) {
	query := `
		SELECT id, age, birthdate, email, created, updated
		FROM users
		WHERE age = ? id >= ?
		LIMIT ?
	`
	rows, err := d.db.QueryContext(ctx, query, age, startID, pageSize)
	if err != nil {
		return nil, fmt.Errorf("failed to query users: %w", err)
	}
	defer rows.Close()

	var entities []*User
	for rows.Next() {
		var entity User
		err := rows.Scan(
			&entity.ID,
            &entity.Age,
            &entity.Birthdate,
            &entity.Email,
            &entity.Created,
            &entity.Updated,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan User: %w", err)
		}
		entities = append(entities, &entity)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return entities, nil
}


/* Delete operations */

// Deletes entity by id,
// returns ErrNotFound in case nothing is deleted.
func (d *UserDAL) Delete(ctx context.Context, entity *User) error {
	if entity.ID == 0 {
		// nothing can be deleted as entity is not created.
		return ErrNotFound
	}

	const operation = "delete"
	start := time.Now()
	dalOperationsTotal.WithLabelValues("User", operation).Inc()

	d.InvalidateCache(ctx, entity)

	_, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return nil, d.delete(ctx, entity.ID)
	})

	if err != nil {
		dbRequestsErrors.WithLabelValues("User", operation).Inc()
		return err
	}

	dbRequestsLatency.WithLabelValues("User", operation).Observe(time.Since(start).Seconds())
	return err
}

func (d *UserDAL) delete(ctx context.Context, id int64) error {
	query := `
		DELETE FROM users
		WHERE id = ?
	`
	res, err := d.db.ExecContext(ctx, query, id)
	if err != nil {
		return fmt.Errorf("failed to delete user: %w", err)
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return ErrNotFound
	}

	return nil
}

/* Store operations */


func (d *UserDAL) Create(ctx context.Context, user *User) (*User, error) {
	const operation = "create"
	start := time.Now()
	dalOperationsTotal.WithLabelValues("user", operation).Inc()

	result, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return d.create(ctx, user)
	})

	if err != nil {
		dbRequestsErrors.WithLabelValues("user", operation).Inc()
		return nil, err
	}

	dbRequestsLatency.WithLabelValues("user", operation).Observe(time.Since(start).Seconds())

	if result == nil {
		return nil, err
	}

	return result.(*User), err
}

func (d *UserDAL) create(ctx context.Context, entity *User) (*User, error) {
	query := `
		INSERT INTO users (
			age,birthdate,email

		VALUES (?,?,?)
	`

	result, err := d.db.ExecContext(ctx, query,
        entity.Age,
        entity.Birthdate,
        entity.Email,)

	if err != nil {
		return nil, fmt.Errorf("failed to insert User: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return nil, fmt.Errorf("failed to get last insert ID: %w", err)
	}

	entity.ID = id
	return entity, nil
}



func (d *UserDAL) Update(ctx context.Context, entity *User) error {
	const operation = "update"
	start := time.Now()
	dalOperationsTotal.WithLabelValues("user", operation).Inc()

	old, _ := d.GetByID(ctx, entity.ID) // Fetch old data before update

	_, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return nil, d.update(ctx, entity)
	})

	if err != nil {
		dbRequestsErrors.WithLabelValues("user", operation).Inc()
		return err
	}

	dbRequestsLatency.WithLabelValues("user", operation).Observe(time.Since(start).Seconds())

	if err == nil {
        d.InvalidateCache(ctx, entity)

        // Invalidate cached lists for old and new
		if old != nil && old.Age != entity.Age {
			d.invalidateListByAge(ctx, old.Age)
		}
    }

	return nil
}

func (d *UserDAL) update(ctx context.Context, user *User) error {
	query := `
		UPDATE users
		SET age = ?, birthdate = ?, email = ?

		WHERE id = ?
	`
	_, err := d.db.ExecContext(ctx, query,
        user.Age,
        user.Birthdate,
        user.Email,user.ID)

	if err != nil {
		return fmt.Errorf("failed to update User: %w", err)
	}
	return nil
}



func (d *UserDAL) Store(ctx context.Context, entity *User) (*User, error) {
	const operation = "store"
	dalOperationsTotal.WithLabelValues("User", operation).Inc()

	var result *User
	var err error

	if entity.ID > 0 {
		// Update existing entity
		err = d.Update(ctx, entity)
		result = entity // Return the same entity after update
	} else {
		// Create new entity
		result, err = d.Create(ctx, entity)
	}

	// Handle errors
	if err != nil {
		return nil, err
	}

	return result, nil
}


