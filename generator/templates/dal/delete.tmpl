{{define "delete"}}
{{- $column := index .Root.Columns .ColumnName }}
// Deletes entity by id,
// returns ErrNotFound in case nothing is deleted.
func (d *{{.Root.Name | pascalCase}}DAL) Delete(ctx context.Context, entity *{{.Root.Name | pascalCase}}) error {
	if entity.ID == 0 {
		// nothing can be deleted as entity is not created.
		return ErrNotFound
	}

	const operation = "delete"
	start := time.Now()
	dalOperationsTotal.WithLabelValues("{{.Root.Name | pascalCase }}", operation).Inc()

	d.InvalidateCache(ctx, entity)

	_, err := d.dbBreaker.Execute(func() (interface{}, error) {
		return nil, d.delete(ctx, entity.ID)
	})

	if err != nil {
		dbRequestsErrors.WithLabelValues("{{.Root.Name | pascalCase}}", operation).Inc()
		return err
	}

	dbRequestsLatency.WithLabelValues("{{.Root.Name | pascalCase}}", operation).Observe(time.Since(start).Seconds())
	return err
}

func (d *{{.Root.Name | pascalCase}}DAL) delete(ctx context.Context, id int64) error {
	query := `
		DELETE FROM {{.Root.Name | snakeCase}}s
		WHERE id = ?
	`
	res, err := d.db.ExecContext(ctx, query, id)
	if err != nil {
		return fmt.Errorf("failed to delete {{.Root.Name | snakeCase}}: %w", err)
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return ErrNotFound
	}

	return nil
}
{{end}}
