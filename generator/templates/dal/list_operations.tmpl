{{define "list_operation"}}
{{- $column := index .Root.Columns .ColumnName }}
func (d *{{.Root.Name | pascalCase}}DAL) ListBy{{.ColumnName | pascalCase}}(ctx context.Context, {{.ColumnName | camelCase}} {{toGoType $column.Type $column.AllowNull}}, startID int64, pageSize int) ([]*{{.Root.Name | pascalCase}}, error) {
	const operation = "list_by_{{.ColumnName | snakeCase}}"
	cacheStart := time.Now()
	dalOperationsTotal.WithLabelValues("{{.Root.Name | snakeCase}}", operation).Inc()

	// 1) Try Cache First
    entities, cacheErr := d.listBy{{.ColumnName | pascalCase}}Redis(ctx, operation, {{.ColumnName | snakeCase}}, startID, pageSize)
    if cacheErr == nil {
        // We got cache HIT
        dalCacheHits.WithLabelValues("{{.Root.Name | snakeCase }}", operation).Inc()
        dalCacheLatency.WithLabelValues("{{.Root.Name | snakeCase}}", operation).Observe(time.Since(cacheStart).Seconds())
        return entities, nil
    }

    // Otherwise, it's a cache miss or decode error
    dalCacheMisses.WithLabelValues("{{.Root.Name | snakeCase}}", operation).Inc()

    // 2) Fallback to DB
	dbStart := time.Now();

    result, err := d.dbBreaker.Execute(func() (interface{}, error) {
        return d.listBy{{.ColumnName | pascalCase}}(ctx, {{.ColumnName | snakeCase}}, startID, pageSize)
    })
    if err != nil {
        // DB also failed
		dbRequestsErrors.WithLabelValues("{{.Root.Name | snakeCase}}", operation).Inc()
        return nil, err
    }

    entities = result.([]*{{.Root.Name | pascalCase}})

    // 3) Store fresh data in Redis
    var buf bytes.Buffer
    enc := gob.NewEncoder(&buf)
    if enc.Encode(entities) == nil {
        // Short TTL for lists
		 dalCacheWrites.WithLabelValues("{{.Root.Name | snakeCase}}", operation).Inc()
        _ = d.cache.Set(ctx, d.listBy{{.ColumnName | pascalCase}}CacheKey({{.ColumnName | snakeCase}}, startID, pageSize), buf.Bytes(), time.Minute*{{.Root.Caching.ListExpirationSeconds}})
    }

    dbRequestsLatency.WithLabelValues("{{.Root.Name | snakeCase}}", operation).Observe(time.Since(dbStart).Seconds())
    return entities, nil
}

// listBy{{.ColumnName | pascalCase}}Redis attempts to retrieve and decode the list from Redis using the cache circuit breaker.
func (d *{{.Root.Name | pascalCase}}DAL) listBy{{.ColumnName | pascalCase}}Redis(
    ctx context.Context,
    operation string,
    {{.ColumnName | camelCase}} {{toGoType $column.Type $column.AllowNull}},
    startID int64,
    pageSize int,
) ([]*{{.Root.Name | pascalCase}}, error) {
    // 1) Build cache key
    cacheKey := d.listBy{{.ColumnName | pascalCase}}CacheKey({{.ColumnName | camelCase}}, startID, pageSize)

    // 2) Use the cache circuit breaker
    result, err := d.cacheBreaker.Execute(func() (interface{}, error) {
        // Try getting data from Redis
        cachedData, redisErr := d.cache.Get(ctx, cacheKey).Bytes()
        if redisErr != nil {
            return nil, redisErr
        }

        var entities []*{{.Root.Name | pascalCase}}
        dec := gob.NewDecoder(bytes.NewReader(cachedData))
        if decodeErr := dec.Decode(&entities); decodeErr != nil {
            return nil, errors.New("cache decode error")
        }

        return entities, nil
    })
    if err != nil {
        // Could be redis.Nil (key not found), decode error, or circuit open
        return nil, err
    }

    // Cache success â†’ return data
    return result.([]*{{.Root.Name | pascalCase}}), nil
}

// Helper to build the cache key
func (d *{{.Root.Name | pascalCase}}DAL) listBy{{.ColumnName | pascalCase}}CacheKey({{.ColumnName | camelCase}} {{toGoType $column.Type $column.AllowNull}}, startID int64, pageSize int) string {
    return fmt.Sprintf("{{.Root.Name | snakeCase}}_list_{{.Root.Version}}:{{.ColumnName | snakeCase}}_%v:start_%d:size_%d", {{.ColumnName | camelCase}}, startID, pageSize)
}

func (d *{{.Root.Name | pascalCase}}DAL) listBy{{.ColumnName | pascalCase}}(ctx context.Context, {{.ColumnName | camelCase}} {{toGoType $column.Type $column.AllowNull}}, startID int64, pageSize int) ([]*{{.Root.Name | pascalCase}}, error) {
	query := `
		SELECT id, {{range $colName, $col := .Root.Columns}}{{$colName | snakeCase}}, {{end}}created, updated
		FROM {{.Root.Name | snakeCase}}s
		WHERE {{.ColumnName | snakeCase}} = ? id >= ?
		LIMIT ?
	`
	rows, err := d.db.QueryContext(ctx, query, {{.ColumnName | camelCase}}, startID, pageSize)
	if err != nil {
		return nil, fmt.Errorf("failed to query {{.Root.Name | snakeCase}}s: %w", err)
	}
	defer rows.Close()

	var entities []*{{.Root.Name | pascalCase}}
	for rows.Next() {
		var entity {{.Root.Name | pascalCase}}
		err := rows.Scan(
			&entity.ID,
            {{range $colName, $col := .Root.Columns}}{{if ne $colName "id"}}&entity.{{$colName | pascalCase}},
            {{end}}{{end}}&entity.Created,
            &entity.Updated,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan {{.Root.Name | pascalCase}}: %w", err)
		}
		entities = append(entities, &entity)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return entities, nil
}
{{end}}
